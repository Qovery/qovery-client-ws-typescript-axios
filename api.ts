/* tslint:disable */
/* eslint-disable */
/**
 * websocket-gateway
 * Describe the websocket endpoints of Qovery
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: erebe@erebe.eu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApplicationStatusDto
 */
export interface ApplicationStatusDto {
    /**
     * 
     * @type {Array<CertificateStatusDto>}
     * @memberof ApplicationStatusDto
     */
    'certificates': Array<CertificateStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationStatusDto
     */
    'id': string;
    /**
     * 
     * @type {Array<PodStatusDto>}
     * @memberof ApplicationStatusDto
     */
    'pods': Array<PodStatusDto>;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof ApplicationStatusDto
     */
    'state': ServiceStateDto;
}


/**
 * 
 * @export
 * @interface CertificateStatusDto
 */
export interface CertificateStatusDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CertificateStatusDto
     */
    'dns_names': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'failed_issuance_attempt_count': number;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'last_failure_issuance_time': number;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'not_after': number;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'not_before': number;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'renewal_time': number;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof CertificateStatusDto
     */
    'state': ServiceStateDto;
    /**
     * 
     * @type {string}
     * @memberof CertificateStatusDto
     */
    'state_message'?: string | null;
}


/**
 * 
 * @export
 * @interface ClusterComputedStatusDto
 */
export interface ClusterComputedStatusDto {
    /**
     * 
     * @type {ClusterStatusGlobalStatus}
     * @memberof ClusterComputedStatusDto
     */
    'global_status': ClusterStatusGlobalStatus;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterComputedStatusDto
     */
    'is_max_nodes_size_reached': boolean;
    /**
     * 
     * @type {QoveryClusterKubeVersionStatus}
     * @memberof ClusterComputedStatusDto
     */
    'kube_version_status': QoveryClusterKubeVersionStatus;
    /**
     * 
     * @type {{ [key: string]: Array<QoveryNodeFailure>; }}
     * @memberof ClusterComputedStatusDto
     */
    'node_warnings': { [key: string]: Array<QoveryNodeFailure>; };
    /**
     * 
     * @type {Array<QoveryComponentDto>}
     * @memberof ClusterComputedStatusDto
     */
    'qovery_components': Array<QoveryComponentDto>;
    /**
     * 
     * @type {Array<QoveryComponentInFailure>}
     * @memberof ClusterComputedStatusDto
     */
    'qovery_components_in_failure': Array<QoveryComponentInFailure>;
}


/**
 * 
 * @export
 * @interface ClusterListNodesResponseDto
 */
export interface ClusterListNodesResponseDto {
    /**
     * 
     * @type {Array<NodeDto>}
     * @memberof ClusterListNodesResponseDto
     */
    'nodes': Array<NodeDto>;
}
/**
 * 
 * @export
 * @interface ClusterMetricsDto
 */
export interface ClusterMetricsDto {
    /**
     * 
     * @type {Array<NodePoolInfoDto>}
     * @memberof ClusterMetricsDto
     */
    'node_pools': Array<NodePoolInfoDto>;
    /**
     * 
     * @type {Array<ClusterNodeDto>}
     * @memberof ClusterMetricsDto
     */
    'nodes': Array<ClusterNodeDto>;
    /**
     * 
     * @type {Array<PvcInfoDto>}
     * @memberof ClusterMetricsDto
     */
    'pvcs': Array<PvcInfoDto>;
}
/**
 * 
 * @export
 * @interface ClusterNodeDto
 */
export interface ClusterNodeDto {
    /**
     * 
     * @type {Array<NodeAddressDto>}
     * @memberof ClusterNodeDto
     */
    'addresses': Array<NodeAddressDto>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ClusterNodeDto
     */
    'annotations': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeDto
     */
    'architecture': string;
    /**
     * 
     * @type {Array<NodeConditionDto>}
     * @memberof ClusterNodeDto
     */
    'conditions': Array<NodeConditionDto>;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeDto
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeDto
     */
    'instance_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeDto
     */
    'kernel_version': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeDto
     */
    'kubelet_version': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ClusterNodeDto
     */
    'labels': { [key: string]: string; };
    /**
     * 
     * @type {MetricsUsageDto}
     * @memberof ClusterNodeDto
     */
    'metrics_usage': MetricsUsageDto;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeDto
     */
    'operating_system': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeDto
     */
    'os_image': string;
    /**
     * 
     * @type {Array<NodePodInfoDto>}
     * @memberof ClusterNodeDto
     */
    'pods': Array<NodePodInfoDto>;
    /**
     * 
     * @type {NodeResourceDto}
     * @memberof ClusterNodeDto
     */
    'resources_allocatable': NodeResourceDto;
    /**
     * 
     * @type {NodeResourceAllocatedDto}
     * @memberof ClusterNodeDto
     */
    'resources_allocated': NodeResourceAllocatedDto;
    /**
     * 
     * @type {NodeResourceDto}
     * @memberof ClusterNodeDto
     */
    'resources_capacity': NodeResourceDto;
    /**
     * 
     * @type {Array<NodeTaintDto>}
     * @memberof ClusterNodeDto
     */
    'taints': Array<NodeTaintDto>;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterNodeDto
     */
    'unschedulable': boolean;
}
/**
 * 
 * @export
 * @interface ClusterStatusDto
 */
export interface ClusterStatusDto {
    /**
     * 
     * @type {ClusterComputedStatusDto}
     * @memberof ClusterStatusDto
     */
    'computed_status': ClusterComputedStatusDto;
    /**
     * 
     * @type {CertificateStatusDto}
     * @memberof ClusterStatusDto
     */
    'tls_certificate'?: CertificateStatusDto | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClusterStatusGlobalStatus = {
    RUNNING: 'RUNNING',
    WARNING: 'WARNING',
    ERROR: 'ERROR'
} as const;

export type ClusterStatusGlobalStatus = typeof ClusterStatusGlobalStatus[keyof typeof ClusterStatusGlobalStatus];


/**
 * 
 * @export
 * @interface ContainerStateDto
 */
export interface ContainerStateDto {
    /**
     * 
     * @type {number}
     * @memberof ContainerStateDto
     */
    'started_at': number;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof ContainerStateDto
     */
    'state': ServiceStateDto;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateDto
     */
    'state_message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateDto
     */
    'state_reason'?: string | null;
}


/**
 * 
 * @export
 * @interface ContainerStateTerminatedDto
 */
export interface ContainerStateTerminatedDto {
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'exit_code': number;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateTerminatedDto
     */
    'exit_code_message': string;
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'finished_at': number;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateTerminatedDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateTerminatedDto
     */
    'reason': string;
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'signal': number;
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'started_at': number;
}
/**
 * 
 * @export
 * @interface ContainerStatusDto
 */
export interface ContainerStatusDto {
    /**
     * 
     * @type {ContainerStateDto}
     * @memberof ContainerStatusDto
     */
    'current_state'?: ContainerStateDto | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerStatusDto
     */
    'image': string;
    /**
     * 
     * @type {ContainerStateTerminatedDto}
     * @memberof ContainerStatusDto
     */
    'last_terminated_state'?: ContainerStateTerminatedDto | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerStatusDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ContainerStatusDto
     */
    'restart_count': number;
}
/**
 * 
 * @export
 * @interface DatabaseStatusDto
 */
export interface DatabaseStatusDto {
    /**
     * 
     * @type {string}
     * @memberof DatabaseStatusDto
     */
    'id': string;
    /**
     * 
     * @type {Array<PodStatusDto>}
     * @memberof DatabaseStatusDto
     */
    'pods': Array<PodStatusDto>;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof DatabaseStatusDto
     */
    'state': ServiceStateDto;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DebugFlavor = {
    REGULAR_PRIVILEGE: 'REGULAR_PRIVILEGE',
    FULL_PRIVILEGE: 'FULL_PRIVILEGE'
} as const;

export type DebugFlavor = typeof DebugFlavor[keyof typeof DebugFlavor];


/**
 * 
 * @export
 * @interface EnvironmentStatusDto
 */
export interface EnvironmentStatusDto {
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'applications': Array<ApplicationStatusDto>;
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'containers': Array<ApplicationStatusDto>;
    /**
     * 
     * @type {Array<DatabaseStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'databases': Array<DatabaseStatusDto>;
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'helms': Array<ApplicationStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatusDto
     */
    'id': string;
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'jobs': Array<ApplicationStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatusDto
     */
    'project_id': string;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof EnvironmentStatusDto
     */
    'state': ServiceStateDto;
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'terraform': Array<ApplicationStatusDto>;
}


/**
 * 
 * @export
 * @interface KubeVersionStatusDriftValue
 */
export interface KubeVersionStatusDriftValue {
    /**
     * 
     * @type {string}
     * @memberof KubeVersionStatusDriftValue
     */
    'expected_kube_version': string;
    /**
     * 
     * @type {string}
     * @memberof KubeVersionStatusDriftValue
     */
    'kube_version': string;
    /**
     * 
     * @type {string}
     * @memberof KubeVersionStatusDriftValue
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface KubeVersionStatusOkValue
 */
export interface KubeVersionStatusOkValue {
    /**
     * 
     * @type {string}
     * @memberof KubeVersionStatusOkValue
     */
    'kube_version': string;
    /**
     * 
     * @type {string}
     * @memberof KubeVersionStatusOkValue
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface KubeVersionStatusUnknownValue
 */
export interface KubeVersionStatusUnknownValue {
    /**
     * 
     * @type {string}
     * @memberof KubeVersionStatusUnknownValue
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface MetricDto
 */
export interface MetricDto {
    /**
     * 
     * @type {number}
     * @memberof MetricDto
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof MetricDto
     */
    'current_percent': number;
    /**
     * 
     * @type {number}
     * @memberof MetricDto
     */
    'limit': number;
    /**
     * 
     * @type {string}
     * @memberof MetricDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {ResourceStatusDto}
     * @memberof MetricDto
     */
    'status': ResourceStatusDto;
    /**
     * 
     * @type {UnitDto}
     * @memberof MetricDto
     */
    'unit': UnitDto;
}


/**
 * 
 * @export
 * @interface MetricsUsageDto
 */
export interface MetricsUsageDto {
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'cpu_milli_usage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'cpu_percent_usage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'ephemeral_storage_percent_usage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'ephemeral_storage_usage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'memory_mib_rss_usage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'memory_mib_working_set_usage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'memory_percent_rss_usage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsUsageDto
     */
    'memory_percent_working_set_usage'?: number | null;
}
/**
 * 
 * @export
 * @interface MissingComponentValue
 */
export interface MissingComponentValue {
    /**
     * 
     * @type {string}
     * @memberof MissingComponentValue
     */
    'component_name': string;
    /**
     * 
     * @type {string}
     * @memberof MissingComponentValue
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NodeAddressDto
 */
export interface NodeAddressDto {
    /**
     * 
     * @type {string}
     * @memberof NodeAddressDto
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof NodeAddressDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NodeConditionDto
 */
export interface NodeConditionDto {
    /**
     * 
     * @type {number}
     * @memberof NodeConditionDto
     */
    'last_heartbeat_time': number;
    /**
     * 
     * @type {number}
     * @memberof NodeConditionDto
     */
    'last_transition_time': number;
    /**
     * 
     * @type {string}
     * @memberof NodeConditionDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NodeConditionDto
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof NodeConditionDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof NodeConditionDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NodeDto
 */
export interface NodeDto {
    /**
     * 
     * @type {string}
     * @memberof NodeDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NodePodErrorStatusDto
 */
export interface NodePodErrorStatusDto {
    /**
     * 
     * @type {string}
     * @memberof NodePodErrorStatusDto
     */
    'container_name': string;
    /**
     * 
     * @type {string}
     * @memberof NodePodErrorStatusDto
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodePodErrorStatusDto
     */
    'reason'?: string | null;
}
/**
 * 
 * @export
 * @interface NodePodInfoDto
 */
export interface NodePodInfoDto {
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'cpu_milli_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'cpu_milli_request'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'ephemeral_storage_mib_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'ephemeral_storage_mib_request'?: number | null;
    /**
     * 
     * @type {Array<NodePodErrorStatusDto>}
     * @memberof NodePodInfoDto
     */
    'error_container_statuses': Array<NodePodErrorStatusDto>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NodePodInfoDto
     */
    'images_version': { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'memory_mib_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'memory_mib_request'?: number | null;
    /**
     * 
     * @type {MetricsUsageDto}
     * @memberof NodePodInfoDto
     */
    'metrics_usage': MetricsUsageDto;
    /**
     * 
     * @type {string}
     * @memberof NodePodInfoDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NodePodInfoDto
     */
    'namespace': string;
    /**
     * 
     * @type {PodQoveryServiceInfoDto}
     * @memberof NodePodInfoDto
     */
    'qovery_service_info'?: PodQoveryServiceInfoDto | null;
    /**
     * 
     * @type {number}
     * @memberof NodePodInfoDto
     */
    'restart_count': number;
    /**
     * 
     * @type {PodStatusPhase}
     * @memberof NodePodInfoDto
     */
    'status_phase': PodStatusPhase;
}


/**
 * 
 * @export
 * @interface NodePoolInfoDto
 */
export interface NodePoolInfoDto {
    /**
     * 
     * @type {number}
     * @memberof NodePoolInfoDto
     */
    'cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof NodePoolInfoDto
     */
    'cpu_milli_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NodePoolInfoDto
     */
    'memory_mib': number;
    /**
     * 
     * @type {number}
     * @memberof NodePoolInfoDto
     */
    'memory_mib_limit'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NodePoolInfoDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof NodePoolInfoDto
     */
    'nodes_count': number;
}
/**
 * 
 * @export
 * @interface NodeResourceAllocatedDto
 */
export interface NodeResourceAllocatedDto {
    /**
     * 
     * @type {number}
     * @memberof NodeResourceAllocatedDto
     */
    'limit_cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof NodeResourceAllocatedDto
     */
    'limit_memory_mib': number;
    /**
     * 
     * @type {number}
     * @memberof NodeResourceAllocatedDto
     */
    'request_cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof NodeResourceAllocatedDto
     */
    'request_memory_mib': number;
}
/**
 * 
 * @export
 * @interface NodeResourceDto
 */
export interface NodeResourceDto {
    /**
     * 
     * @type {number}
     * @memberof NodeResourceDto
     */
    'cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof NodeResourceDto
     */
    'ephemeral_storage_mib': number;
    /**
     * 
     * @type {number}
     * @memberof NodeResourceDto
     */
    'memory_mib': number;
    /**
     * 
     * @type {number}
     * @memberof NodeResourceDto
     */
    'pods': number;
}
/**
 * 
 * @export
 * @interface NodeTaintDto
 */
export interface NodeTaintDto {
    /**
     * 
     * @type {string}
     * @memberof NodeTaintDto
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof NodeTaintDto
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof NodeTaintDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface PodDto
 */
export interface PodDto {
    /**
     * 
     * @type {string}
     * @memberof PodDto
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PodDto
     */
    'ports': Array<number>;
}
/**
 * 
 * @export
 * @interface PodInErrorValue
 */
export interface PodInErrorValue {
    /**
     * 
     * @type {string}
     * @memberof PodInErrorValue
     */
    'component_name': string;
    /**
     * 
     * @type {string}
     * @memberof PodInErrorValue
     */
    'container_name': string;
    /**
     * 
     * @type {QoveryComponentContainerStatusLevel}
     * @memberof PodInErrorValue
     */
    'level': QoveryComponentContainerStatusLevel;
    /**
     * 
     * @type {string}
     * @memberof PodInErrorValue
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PodInErrorValue
     */
    'pod_name': string;
    /**
     * 
     * @type {string}
     * @memberof PodInErrorValue
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PodInErrorValue
     */
    'type': string;
}


/**
 * 
 * @export
 * @interface PodInfoDto
 */
export interface PodInfoDto {
    /**
     * 
     * @type {number}
     * @memberof PodInfoDto
     */
    'cpu_milli_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PodInfoDto
     */
    'cpu_milli_request'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PodInfoDto
     */
    'created_at': number;
    /**
     * 
     * @type {Array<NodePodErrorStatusDto>}
     * @memberof PodInfoDto
     */
    'error_container_statuses': Array<NodePodErrorStatusDto>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PodInfoDto
     */
    'images_version': { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof PodInfoDto
     */
    'memory_mib_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PodInfoDto
     */
    'memory_mib_request'?: number | null;
    /**
     * 
     * @type {MetricsUsageDto}
     * @memberof PodInfoDto
     */
    'metrics_usage': MetricsUsageDto;
    /**
     * 
     * @type {string}
     * @memberof PodInfoDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PodInfoDto
     */
    'namespace': string;
    /**
     * 
     * @type {number}
     * @memberof PodInfoDto
     */
    'restart_count': number;
}
/**
 * 
 * @export
 * @interface PodKubernetesEventDto
 */
export interface PodKubernetesEventDto {
    /**
     * 
     * @type {number}
     * @memberof PodKubernetesEventDto
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof PodKubernetesEventDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PodKubernetesEventDto
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof PodKubernetesEventDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface PodQoveryServiceInfoDto
 */
export interface PodQoveryServiceInfoDto {
    /**
     * 
     * @type {string}
     * @memberof PodQoveryServiceInfoDto
     */
    'environment_id': string;
    /**
     * 
     * @type {string}
     * @memberof PodQoveryServiceInfoDto
     */
    'environment_name': string;
    /**
     * 
     * @type {string}
     * @memberof PodQoveryServiceInfoDto
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof PodQoveryServiceInfoDto
     */
    'project_name': string;
    /**
     * 
     * @type {string}
     * @memberof PodQoveryServiceInfoDto
     */
    'service_id': string;
    /**
     * 
     * @type {string}
     * @memberof PodQoveryServiceInfoDto
     */
    'service_name': string;
}
/**
 * 
 * @export
 * @interface PodStatusDto
 */
export interface PodStatusDto {
    /**
     * 
     * @type {Array<ContainerStatusDto>}
     * @memberof PodStatusDto
     */
    'containers': Array<ContainerStatusDto>;
    /**
     * 
     * @type {Array<PodKubernetesEventDto>}
     * @memberof PodStatusDto
     */
    'last_events': Array<PodKubernetesEventDto>;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PodStatusDto
     */
    'restart_count': number;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'service_version': string;
    /**
     * 
     * @type {number}
     * @memberof PodStatusDto
     */
    'started_at': number;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof PodStatusDto
     */
    'state': ServiceStateDto;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'state_message': string;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'state_reason': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PodStatusPhase = {
    PENDING: 'PENDING',
    RUNNING: 'RUNNING',
    SUCCEEDED: 'SUCCEEDED',
    FAILED: 'FAILED',
    UNKNOWN: 'UNKNOWN'
} as const;

export type PodStatusPhase = typeof PodStatusPhase[keyof typeof PodStatusPhase];


/**
 * 
 * @export
 * @interface PvcInfoDto
 */
export interface PvcInfoDto {
    /**
     * 
     * @type {number}
     * @memberof PvcInfoDto
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof PvcInfoDto
     */
    'disk_mib_capacity': number;
    /**
     * 
     * @type {number}
     * @memberof PvcInfoDto
     */
    'disk_mib_usage': number;
    /**
     * 
     * @type {number}
     * @memberof PvcInfoDto
     */
    'disk_percent_usage': number;
    /**
     * 
     * @type {string}
     * @memberof PvcInfoDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PvcInfoDto
     */
    'namespace'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PvcInfoDto
     */
    'pod_name'?: string | null;
    /**
     * 
     * @type {PodQoveryServiceInfoDto}
     * @memberof PvcInfoDto
     */
    'qovery_service_info'?: PodQoveryServiceInfoDto | null;
    /**
     * 
     * @type {string}
     * @memberof PvcInfoDto
     */
    'status'?: string | null;
}
/**
 * @type QoveryClusterKubeVersionStatus
 * @export
 */
export type QoveryClusterKubeVersionStatus = { type: 'DRIFT' } & KubeVersionStatusDriftValue | { type: 'OK' } & KubeVersionStatusOkValue | { type: 'UNKNOWN' } & KubeVersionStatusUnknownValue;

/**
 * 
 * @export
 * @interface QoveryComponentContainerStatusIssue
 */
export interface QoveryComponentContainerStatusIssue {
    /**
     * 
     * @type {QoveryComponentContainerStatusLevel}
     * @memberof QoveryComponentContainerStatusIssue
     */
    'level': QoveryComponentContainerStatusLevel;
    /**
     * 
     * @type {string}
     * @memberof QoveryComponentContainerStatusIssue
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QoveryComponentContainerStatusIssue
     */
    'reason'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const QoveryComponentContainerStatusLevel = {
    ERROR: 'ERROR',
    WARNING: 'WARNING'
} as const;

export type QoveryComponentContainerStatusLevel = typeof QoveryComponentContainerStatusLevel[keyof typeof QoveryComponentContainerStatusLevel];


/**
 * 
 * @export
 * @interface QoveryComponentDto
 */
export interface QoveryComponentDto {
    /**
     * 
     * @type {Array<QoveryComponentInFailure>}
     * @memberof QoveryComponentDto
     */
    'error_detail': Array<QoveryComponentInFailure>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QoveryComponentDto
     */
    'images_version': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QoveryComponentDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof QoveryComponentDto
     */
    'namespace': string;
    /**
     * 
     * @type {QoveryComponentStatus}
     * @memberof QoveryComponentDto
     */
    'status': QoveryComponentStatus;
}


/**
 * @type QoveryComponentInFailure
 * @export
 */
export type QoveryComponentInFailure = { type: 'MISSING_COMPONENT' } & MissingComponentValue | { type: 'POD_IN_ERROR' } & PodInErrorValue;

/**
 * 
 * @export
 * @enum {string}
 */

export const QoveryComponentStatus = {
    RUNNING: 'RUNNING',
    ERROR: 'ERROR'
} as const;

export type QoveryComponentStatus = typeof QoveryComponentStatus[keyof typeof QoveryComponentStatus];


/**
 * 
 * @export
 * @interface QoveryNodeAttributes
 */
export interface QoveryNodeAttributes {
    /**
     * 
     * @type {string}
     * @memberof QoveryNodeAttributes
     */
    'node_pool_name'?: string | null;
}
/**
 * 
 * @export
 * @interface QoveryNodeFailure
 */
export interface QoveryNodeFailure {
    /**
     * 
     * @type {string}
     * @memberof QoveryNodeFailure
     */
    'message': string;
    /**
     * 
     * @type {QoveryNodeAttributes}
     * @memberof QoveryNodeFailure
     */
    'node_attributes': QoveryNodeAttributes;
    /**
     * 
     * @type {string}
     * @memberof QoveryNodeFailure
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof QoveryNodeFailure
     */
    'type': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResourceStatusDto = {
    OK: 'OK',
    WARNING: 'WARNING',
    ALERT: 'ALERT'
} as const;

export type ResourceStatusDto = typeof ResourceStatusDto[keyof typeof ResourceStatusDto];


/**
 * 
 * @export
 * @interface ServiceInfraLogResponseDto
 */
export interface ServiceInfraLogResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServiceInfraLogResponseDto
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceInfraLogResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ServiceListPodsResponseDto
 */
export interface ServiceListPodsResponseDto {
    /**
     * 
     * @type {Array<PodDto>}
     * @memberof ServiceListPodsResponseDto
     */
    'pods': Array<PodDto>;
}
/**
 * 
 * @export
 * @interface ServiceLogResponseDto
 */
export interface ServiceLogResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ServiceLogResponseDto
     */
    'container_name': string;
    /**
     * 
     * @type {number}
     * @memberof ServiceLogResponseDto
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceLogResponseDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLogResponseDto
     */
    'pod_name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLogResponseDto
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ServiceMetricsDto
 */
export interface ServiceMetricsDto {
    /**
     * 
     * @type {MetricDto}
     * @memberof ServiceMetricsDto
     */
    'cpu': MetricDto;
    /**
     * 
     * @type {MetricDto}
     * @memberof ServiceMetricsDto
     */
    'memory': MetricDto;
    /**
     * 
     * @type {string}
     * @memberof ServiceMetricsDto
     */
    'pod_name': string;
    /**
     * 
     * @type {Array<MetricDto>}
     * @memberof ServiceMetricsDto
     */
    'storages': Array<MetricDto>;
}
/**
 * 
 * @export
 * @interface ServiceMetricsV2Dto
 */
export interface ServiceMetricsV2Dto {
    /**
     * 
     * @type {Array<PodInfoDto>}
     * @memberof ServiceMetricsV2Dto
     */
    'pods': Array<PodInfoDto>;
    /**
     * 
     * @type {Array<PvcInfoDto>}
     * @memberof ServiceMetricsV2Dto
     */
    'pvcs': Array<PvcInfoDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceStateDto = {
    STARTING: 'STARTING',
    RUNNING: 'RUNNING',
    ERROR: 'ERROR',
    STOPPING: 'STOPPING',
    STOPPED: 'STOPPED',
    COMPLETED: 'COMPLETED',
    WARNING: 'WARNING'
} as const;

export type ServiceStateDto = typeof ServiceStateDto[keyof typeof ServiceStateDto];


/**
 * 
 * @export
 * @interface ServiceStatusDto
 */
export interface ServiceStatusDto {
    /**
     * 
     * @type {Array<EnvironmentStatusDto>}
     * @memberof ServiceStatusDto
     */
    'environments': Array<EnvironmentStatusDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceType = {
    APPLICATION: 'APPLICATION',
    CONTAINER: 'CONTAINER',
    DATABASE: 'DATABASE',
    JOB: 'JOB',
    HELM: 'HELM',
    TERRAFORM: 'TERRAFORM'
} as const;

export type ServiceType = typeof ServiceType[keyof typeof ServiceType];


/**
 * 
 * @export
 * @enum {string}
 */

export const UnitDto = {
    M_CPU: 'mCPU',
    MI_B: 'MiB',
    GI_B: 'GiB'
} as const;

export type UnitDto = typeof UnitDto[keyof typeof UnitDto];



/**
 * ClusterListNodesApi - axios parameter creator
 * @export
 */
export const ClusterListNodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleClusterListNodesRequest: async (organization: string, cluster: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleClusterListNodesRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleClusterListNodesRequest', 'cluster', cluster)
            const localVarPath = `/cluster/node`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterListNodesApi - functional programming interface
 * @export
 */
export const ClusterListNodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterListNodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleClusterListNodesRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterListNodesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleClusterListNodesRequest(organization, cluster, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterListNodesApi.handleClusterListNodesRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterListNodesApi - factory interface
 * @export
 */
export const ClusterListNodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterListNodesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleClusterListNodesRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterListNodesResponseDto> {
            return localVarFp.handleClusterListNodesRequest(organization, cluster, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterListNodesApi - object-oriented interface
 * @export
 * @class ClusterListNodesApi
 * @extends {BaseAPI}
 */
export class ClusterListNodesApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterListNodesApi
     */
    public handleClusterListNodesRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig) {
        return ClusterListNodesApiFp(this.configuration).handleClusterListNodesRequest(organization, cluster, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterMetricsApi - axios parameter creator
 * @export
 */
export const ClusterMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleClusterMetricsRequest: async (organization: string, cluster: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleClusterMetricsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleClusterMetricsRequest', 'cluster', cluster)
            const localVarPath = `/cluster/metrics`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterMetricsApi - functional programming interface
 * @export
 */
export const ClusterMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleClusterMetricsRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterMetricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleClusterMetricsRequest(organization, cluster, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMetricsApi.handleClusterMetricsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterMetricsApi - factory interface
 * @export
 */
export const ClusterMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterMetricsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleClusterMetricsRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterMetricsDto> {
            return localVarFp.handleClusterMetricsRequest(organization, cluster, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterMetricsApi - object-oriented interface
 * @export
 * @class ClusterMetricsApi
 * @extends {BaseAPI}
 */
export class ClusterMetricsApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMetricsApi
     */
    public handleClusterMetricsRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig) {
        return ClusterMetricsApiFp(this.configuration).handleClusterMetricsRequest(organization, cluster, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterStatusApi - axios parameter creator
 * @export
 */
export const ClusterStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleClusterStatusRequest: async (organization: string, cluster: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleClusterStatusRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleClusterStatusRequest', 'cluster', cluster)
            const localVarPath = `/cluster/status`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterStatusApi - functional programming interface
 * @export
 */
export const ClusterStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleClusterStatusRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleClusterStatusRequest(organization, cluster, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterStatusApi.handleClusterStatusRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterStatusApi - factory interface
 * @export
 */
export const ClusterStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterStatusApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleClusterStatusRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterStatusDto> {
            return localVarFp.handleClusterStatusRequest(organization, cluster, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterStatusApi - object-oriented interface
 * @export
 * @class ClusterStatusApi
 * @extends {BaseAPI}
 */
export class ClusterStatusApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterStatusApi
     */
    public handleClusterStatusRequest(organization: string, cluster: string, options?: RawAxiosRequestConfig) {
        return ClusterStatusApiFp(this.configuration).handleClusterStatusRequest(organization, cluster, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string | null} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string | null} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentLogsRequest: async (organization: string, cluster: string | null, project: string, environment: string, version: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'environment', environment)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'version', version)
            const localVarPath = `/deployment/logs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organization 
         * @param {string | null} cluster 
         * @param {string} project 
         * @param {string | null} environment 
         * @param {string | null} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentStatusRequest: async (organization: string, cluster: string | null, project: string, environment: string | null, version: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'environment', environment)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'version', version)
            const localVarPath = `/deployment/status`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string | null} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string | null} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleDeploymentLogsRequest(organization: string, cluster: string | null, project: string, environment: string, version: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleDeploymentLogsRequest(organization, cluster, project, environment, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentApi.handleDeploymentLogsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organization 
         * @param {string | null} cluster 
         * @param {string} project 
         * @param {string | null} environment 
         * @param {string | null} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleDeploymentStatusRequest(organization: string, cluster: string | null, project: string, environment: string | null, version: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleDeploymentStatusRequest(organization, cluster, project, environment, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentApi.handleDeploymentStatusRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string | null} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string | null} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentLogsRequest(organization: string, cluster: string | null, project: string, environment: string, version: string | null, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.handleDeploymentLogsRequest(organization, cluster, project, environment, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organization 
         * @param {string | null} cluster 
         * @param {string} project 
         * @param {string | null} environment 
         * @param {string | null} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentStatusRequest(organization: string, cluster: string | null, project: string, environment: string | null, version: string | null, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.handleDeploymentStatusRequest(organization, cluster, project, environment, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string | null} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string | null} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public handleDeploymentLogsRequest(organization: string, cluster: string | null, project: string, environment: string, version: string | null, options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).handleDeploymentLogsRequest(organization, cluster, project, environment, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organization 
     * @param {string | null} cluster 
     * @param {string} project 
     * @param {string | null} environment 
     * @param {string | null} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public handleDeploymentStatusRequest(organization: string, cluster: string | null, project: string, environment: string | null, version: string | null, options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).handleDeploymentStatusRequest(organization, cluster, project, environment, version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string | null} project 
         * @param {string | null} environment 
         * @param {string | null} service 
         * @param {string} infraComponentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleInfraLogsRequest: async (organization: string, cluster: string, project: string | null, environment: string | null, service: string | null, infraComponentType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'service', service)
            // verify required parameter 'infraComponentType' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'infraComponentType', infraComponentType)
            const localVarPath = `/infra/logs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"infra_component_type"}}`, encodeURIComponent(String(infraComponentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string | null} podName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceLogsRequest: async (organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'service', service)
            // verify required parameter 'podName' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'podName', podName)
            const localVarPath = `/service/logs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"pod_name"}}`, encodeURIComponent(String(podName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string | null} project 
         * @param {string | null} environment 
         * @param {string | null} service 
         * @param {string} infraComponentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleInfraLogsRequest(organization: string, cluster: string, project: string | null, environment: string | null, service: string | null, infraComponentType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInfraLogResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleInfraLogsRequest(organization, cluster, project, environment, service, infraComponentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.handleInfraLogsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string | null} podName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleServiceLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceLogResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleServiceLogsRequest(organization, cluster, project, environment, service, podName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.handleServiceLogsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string | null} project 
         * @param {string | null} environment 
         * @param {string | null} service 
         * @param {string} infraComponentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleInfraLogsRequest(organization: string, cluster: string, project: string | null, environment: string | null, service: string | null, infraComponentType: string, options?: RawAxiosRequestConfig): AxiosPromise<ServiceInfraLogResponseDto> {
            return localVarFp.handleInfraLogsRequest(organization, cluster, project, environment, service, infraComponentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string | null} podName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, options?: RawAxiosRequestConfig): AxiosPromise<ServiceLogResponseDto> {
            return localVarFp.handleServiceLogsRequest(organization, cluster, project, environment, service, podName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string | null} project 
     * @param {string | null} environment 
     * @param {string | null} service 
     * @param {string} infraComponentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public handleInfraLogsRequest(organization: string, cluster: string, project: string | null, environment: string | null, service: string | null, infraComponentType: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).handleInfraLogsRequest(organization, cluster, project, environment, service, infraComponentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} service 
     * @param {string | null} podName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public handleServiceLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).handleServiceLogsRequest(organization, cluster, project, environment, service, podName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RemoteDebugApi - axios parameter creator
 * @export
 */
export const RemoteDebugApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {DebugFlavor} flavor 
         * @param {number} ttyWidth 
         * @param {number} ttyHeight 
         * @param {string | null} nodeSelector 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleShellRemoteDebug: async (organization: string, cluster: string, flavor: DebugFlavor, ttyWidth: number, ttyHeight: number, nodeSelector: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleShellRemoteDebug', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleShellRemoteDebug', 'cluster', cluster)
            // verify required parameter 'flavor' is not null or undefined
            assertParamExists('handleShellRemoteDebug', 'flavor', flavor)
            // verify required parameter 'ttyWidth' is not null or undefined
            assertParamExists('handleShellRemoteDebug', 'ttyWidth', ttyWidth)
            // verify required parameter 'ttyHeight' is not null or undefined
            assertParamExists('handleShellRemoteDebug', 'ttyHeight', ttyHeight)
            // verify required parameter 'nodeSelector' is not null or undefined
            assertParamExists('handleShellRemoteDebug', 'nodeSelector', nodeSelector)
            const localVarPath = `/shell/debug`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"tty_width"}}`, encodeURIComponent(String(ttyWidth)))
                .replace(`{${"tty_height"}}`, encodeURIComponent(String(ttyHeight)))
                .replace(`{${"node_selector"}}`, encodeURIComponent(String(nodeSelector)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteDebugApi - functional programming interface
 * @export
 */
export const RemoteDebugApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemoteDebugApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {DebugFlavor} flavor 
         * @param {number} ttyWidth 
         * @param {number} ttyHeight 
         * @param {string | null} nodeSelector 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleShellRemoteDebug(organization: string, cluster: string, flavor: DebugFlavor, ttyWidth: number, ttyHeight: number, nodeSelector: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleShellRemoteDebug(organization, cluster, flavor, ttyWidth, ttyHeight, nodeSelector, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteDebugApi.handleShellRemoteDebug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RemoteDebugApi - factory interface
 * @export
 */
export const RemoteDebugApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemoteDebugApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {DebugFlavor} flavor 
         * @param {number} ttyWidth 
         * @param {number} ttyHeight 
         * @param {string | null} nodeSelector 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleShellRemoteDebug(organization: string, cluster: string, flavor: DebugFlavor, ttyWidth: number, ttyHeight: number, nodeSelector: string | null, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.handleShellRemoteDebug(organization, cluster, flavor, ttyWidth, ttyHeight, nodeSelector, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemoteDebugApi - object-oriented interface
 * @export
 * @class RemoteDebugApi
 * @extends {BaseAPI}
 */
export class RemoteDebugApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {DebugFlavor} flavor 
     * @param {number} ttyWidth 
     * @param {number} ttyHeight 
     * @param {string | null} nodeSelector 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteDebugApi
     */
    public handleShellRemoteDebug(organization: string, cluster: string, flavor: DebugFlavor, ttyWidth: number, ttyHeight: number, nodeSelector: string | null, options?: RawAxiosRequestConfig) {
        return RemoteDebugApiFp(this.configuration).handleShellRemoteDebug(organization, cluster, flavor, ttyWidth, ttyHeight, nodeSelector, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceListPodsApi - axios parameter creator
 * @export
 */
export const ServiceListPodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceListPodsRequest: async (organization: string, cluster: string, project: string, environment: string, service: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleServiceListPodsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleServiceListPodsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleServiceListPodsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleServiceListPodsRequest', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleServiceListPodsRequest', 'service', service)
            const localVarPath = `/service/pods`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceListPodsApi - functional programming interface
 * @export
 */
export const ServiceListPodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceListPodsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleServiceListPodsRequest(organization: string, cluster: string, project: string, environment: string, service: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceListPodsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleServiceListPodsRequest(organization, cluster, project, environment, service, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceListPodsApi.handleServiceListPodsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceListPodsApi - factory interface
 * @export
 */
export const ServiceListPodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceListPodsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceListPodsRequest(organization: string, cluster: string, project: string, environment: string, service: string, options?: RawAxiosRequestConfig): AxiosPromise<ServiceListPodsResponseDto> {
            return localVarFp.handleServiceListPodsRequest(organization, cluster, project, environment, service, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceListPodsApi - object-oriented interface
 * @export
 * @class ServiceListPodsApi
 * @extends {BaseAPI}
 */
export class ServiceListPodsApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceListPodsApi
     */
    public handleServiceListPodsRequest(organization: string, cluster: string, project: string, environment: string, service: string, options?: RawAxiosRequestConfig) {
        return ServiceListPodsApiFp(this.configuration).handleServiceListPodsRequest(organization, cluster, project, environment, service, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceMetricsApi - axios parameter creator
 * @export
 */
export const ServiceMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {ServiceType} serviceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMetricsRequest: async (organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleMetricsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleMetricsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleMetricsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleMetricsRequest', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleMetricsRequest', 'service', service)
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('handleMetricsRequest', 'serviceType', serviceType)
            const localVarPath = `/service/metrics`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"service_type"}}`, encodeURIComponent(String(serviceType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceMetricsApi - functional programming interface
 * @export
 */
export const ServiceMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {ServiceType} serviceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleMetricsRequest(organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceMetricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleMetricsRequest(organization, cluster, project, environment, service, serviceType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceMetricsApi.handleMetricsRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceMetricsApi - factory interface
 * @export
 */
export const ServiceMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceMetricsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {ServiceType} serviceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMetricsRequest(organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options?: RawAxiosRequestConfig): AxiosPromise<ServiceMetricsDto> {
            return localVarFp.handleMetricsRequest(organization, cluster, project, environment, service, serviceType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceMetricsApi - object-oriented interface
 * @export
 * @class ServiceMetricsApi
 * @extends {BaseAPI}
 */
export class ServiceMetricsApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} service 
     * @param {ServiceType} serviceType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceMetricsApi
     */
    public handleMetricsRequest(organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options?: RawAxiosRequestConfig) {
        return ServiceMetricsApiFp(this.configuration).handleMetricsRequest(organization, cluster, project, environment, service, serviceType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceStatusApi - axios parameter creator
 * @export
 */
export const ServiceStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string | null} project 
         * @param {string | null} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceStatusRequest: async (organization: string, cluster: string, project: string | null, environment: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'environment', environment)
            const localVarPath = `/service/status`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceStatusApi - functional programming interface
 * @export
 */
export const ServiceStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string | null} project 
         * @param {string | null} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleServiceStatusRequest(organization: string, cluster: string, project: string | null, environment: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleServiceStatusRequest(organization, cluster, project, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceStatusApi.handleServiceStatusRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceStatusApi - factory interface
 * @export
 */
export const ServiceStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceStatusApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string | null} project 
         * @param {string | null} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceStatusRequest(organization: string, cluster: string, project: string | null, environment: string | null, options?: RawAxiosRequestConfig): AxiosPromise<ServiceStatusDto> {
            return localVarFp.handleServiceStatusRequest(organization, cluster, project, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceStatusApi - object-oriented interface
 * @export
 * @class ServiceStatusApi
 * @extends {BaseAPI}
 */
export class ServiceStatusApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string | null} project 
     * @param {string | null} environment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStatusApi
     */
    public handleServiceStatusRequest(organization: string, cluster: string, project: string | null, environment: string | null, options?: RawAxiosRequestConfig) {
        return ServiceStatusApiFp(this.configuration).handleServiceStatusRequest(organization, cluster, project, environment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShellApi - axios parameter creator
 * @export
 */
export const ShellApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string | null} podName 
         * @param {string | null} containerName 
         * @param {Array<string>} command 
         * @param {number} ttyWidth 
         * @param {number} ttyHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleShellExec: async (organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, containerName: string | null, command: Array<string>, ttyWidth: number, ttyHeight: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleShellExec', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleShellExec', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleShellExec', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleShellExec', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleShellExec', 'service', service)
            // verify required parameter 'podName' is not null or undefined
            assertParamExists('handleShellExec', 'podName', podName)
            // verify required parameter 'containerName' is not null or undefined
            assertParamExists('handleShellExec', 'containerName', containerName)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('handleShellExec', 'command', command)
            // verify required parameter 'ttyWidth' is not null or undefined
            assertParamExists('handleShellExec', 'ttyWidth', ttyWidth)
            // verify required parameter 'ttyHeight' is not null or undefined
            assertParamExists('handleShellExec', 'ttyHeight', ttyHeight)
            const localVarPath = `/shell/exec`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"pod_name"}}`, encodeURIComponent(String(podName)))
                .replace(`{${"container_name"}}`, encodeURIComponent(String(containerName)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)))
                .replace(`{${"tty_width"}}`, encodeURIComponent(String(ttyWidth)))
                .replace(`{${"tty_height"}}`, encodeURIComponent(String(ttyHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShellApi - functional programming interface
 * @export
 */
export const ShellApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShellApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string | null} podName 
         * @param {string | null} containerName 
         * @param {Array<string>} command 
         * @param {number} ttyWidth 
         * @param {number} ttyHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleShellExec(organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, containerName: string | null, command: Array<string>, ttyWidth: number, ttyHeight: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleShellExec(organization, cluster, project, environment, service, podName, containerName, command, ttyWidth, ttyHeight, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShellApi.handleShellExec']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShellApi - factory interface
 * @export
 */
export const ShellApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShellApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string | null} podName 
         * @param {string | null} containerName 
         * @param {Array<string>} command 
         * @param {number} ttyWidth 
         * @param {number} ttyHeight 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleShellExec(organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, containerName: string | null, command: Array<string>, ttyWidth: number, ttyHeight: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.handleShellExec(organization, cluster, project, environment, service, podName, containerName, command, ttyWidth, ttyHeight, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShellApi - object-oriented interface
 * @export
 * @class ShellApi
 * @extends {BaseAPI}
 */
export class ShellApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} service 
     * @param {string | null} podName 
     * @param {string | null} containerName 
     * @param {Array<string>} command 
     * @param {number} ttyWidth 
     * @param {number} ttyHeight 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellApi
     */
    public handleShellExec(organization: string, cluster: string, project: string, environment: string, service: string, podName: string | null, containerName: string | null, command: Array<string>, ttyWidth: number, ttyHeight: number, options?: RawAxiosRequestConfig) {
        return ShellApiFp(this.configuration).handleShellExec(organization, cluster, project, environment, service, podName, containerName, command, ttyWidth, ttyHeight, options).then((request) => request(this.axios, this.basePath));
    }
}



