/* tslint:disable */
/* eslint-disable */
/**
 * websocket-gateway
 * Describe the weboscket endpoints
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: erebe@erebe.eu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApplicationStatusDto
 */
export interface ApplicationStatusDto {
    /**
     * 
     * @type {Array<CertificateStatusDto>}
     * @memberof ApplicationStatusDto
     */
    'certificates': Array<CertificateStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationStatusDto
     */
    'id': string;
    /**
     * 
     * @type {Array<PodStatusDto>}
     * @memberof ApplicationStatusDto
     */
    'pods': Array<PodStatusDto>;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof ApplicationStatusDto
     */
    'state': ServiceStateDto;
}
/**
 * 
 * @export
 * @interface CertificateStatusDto
 */
export interface CertificateStatusDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CertificateStatusDto
     */
    'dns_names': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'failed_issuance_attempt_count': number;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'last_failure_issuance_time'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'not_after'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'not_before'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CertificateStatusDto
     */
    'renewal_time'?: number | null;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof CertificateStatusDto
     */
    'state': ServiceStateDto;
    /**
     * 
     * @type {string}
     * @memberof CertificateStatusDto
     */
    'state_message'?: string | null;
}
/**
 * 
 * @export
 * @interface ContainerStateDto
 */
export interface ContainerStateDto {
    /**
     * 
     * @type {number}
     * @memberof ContainerStateDto
     */
    'started_at'?: number | null;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof ContainerStateDto
     */
    'state': ServiceStateDto;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateDto
     */
    'state_message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateDto
     */
    'state_reason'?: string | null;
}
/**
 * 
 * @export
 * @interface ContainerStateTerminatedDto
 */
export interface ContainerStateTerminatedDto {
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'exit_code': number;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateTerminatedDto
     */
    'exit_code_message': string;
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'finished_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateTerminatedDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerStateTerminatedDto
     */
    'reason': string;
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'signal': number;
    /**
     * 
     * @type {number}
     * @memberof ContainerStateTerminatedDto
     */
    'started_at'?: number | null;
}
/**
 * 
 * @export
 * @interface ContainerStatusDto
 */
export interface ContainerStatusDto {
    /**
     * 
     * @type {ContainerStateDto}
     * @memberof ContainerStatusDto
     */
    'current_state'?: ContainerStateDto | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerStatusDto
     */
    'image': string;
    /**
     * 
     * @type {ContainerStateTerminatedDto}
     * @memberof ContainerStatusDto
     */
    'last_terminated_state'?: ContainerStateTerminatedDto | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerStatusDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ContainerStatusDto
     */
    'restart_count': number;
}
/**
 * 
 * @export
 * @interface DatabaseStatusDto
 */
export interface DatabaseStatusDto {
    /**
     * 
     * @type {string}
     * @memberof DatabaseStatusDto
     */
    'id': string;
    /**
     * 
     * @type {Array<PodStatusDto>}
     * @memberof DatabaseStatusDto
     */
    'pods': Array<PodStatusDto>;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof DatabaseStatusDto
     */
    'state': ServiceStateDto;
}
/**
 * 
 * @export
 * @interface EnvironmentStatusDto
 */
export interface EnvironmentStatusDto {
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'applications': Array<ApplicationStatusDto>;
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'containers': Array<ApplicationStatusDto>;
    /**
     * 
     * @type {Array<DatabaseStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'databases': Array<DatabaseStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatusDto
     */
    'id': string;
    /**
     * 
     * @type {Array<ApplicationStatusDto>}
     * @memberof EnvironmentStatusDto
     */
    'jobs': Array<ApplicationStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatusDto
     */
    'project_id': string;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof EnvironmentStatusDto
     */
    'state': ServiceStateDto;
}
/**
 * 
 * @export
 * @interface MetricDto
 */
export interface MetricDto {
    /**
     * 
     * @type {number}
     * @memberof MetricDto
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof MetricDto
     */
    'current_percent': number;
    /**
     * 
     * @type {number}
     * @memberof MetricDto
     */
    'limit': number;
    /**
     * 
     * @type {string}
     * @memberof MetricDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {ResourceStatusDto}
     * @memberof MetricDto
     */
    'status': ResourceStatusDto;
    /**
     * 
     * @type {UnitDto}
     * @memberof MetricDto
     */
    'unit': UnitDto;
}
/**
 * 
 * @export
 * @interface PodStatusDto
 */
export interface PodStatusDto {
    /**
     * 
     * @type {Array<ContainerStatusDto>}
     * @memberof PodStatusDto
     */
    'containers': Array<ContainerStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PodStatusDto
     */
    'restart_count': number;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'service_version': string;
    /**
     * 
     * @type {number}
     * @memberof PodStatusDto
     */
    'started_at'?: number | null;
    /**
     * 
     * @type {ServiceStateDto}
     * @memberof PodStatusDto
     */
    'state': ServiceStateDto;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'state_message': string;
    /**
     * 
     * @type {string}
     * @memberof PodStatusDto
     */
    'state_reason': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ResourceStatusDto {
    OK = 'OK',
    WARNING = 'WARNING',
    ALERT = 'ALERT'
}

/**
 * 
 * @export
 * @interface ServiceInfraLogResponseDto
 */
export interface ServiceInfraLogResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServiceInfraLogResponseDto
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceInfraLogResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ServiceLogResponseDto
 */
export interface ServiceLogResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServiceLogResponseDto
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceLogResponseDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLogResponseDto
     */
    'pod_name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLogResponseDto
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ServiceMetricsDto
 */
export interface ServiceMetricsDto {
    /**
     * 
     * @type {MetricDto}
     * @memberof ServiceMetricsDto
     */
    'cpu': MetricDto;
    /**
     * 
     * @type {MetricDto}
     * @memberof ServiceMetricsDto
     */
    'memory': MetricDto;
    /**
     * 
     * @type {string}
     * @memberof ServiceMetricsDto
     */
    'pod_name': string;
    /**
     * 
     * @type {Array<MetricDto>}
     * @memberof ServiceMetricsDto
     */
    'storages': Array<MetricDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ServiceStateDto {
    STARTING = 'STARTING',
    RUNNING = 'RUNNING',
    ERROR = 'ERROR',
    STOPPING = 'STOPPING',
    STOPPED = 'STOPPED',
    COMPLETED = 'COMPLETED',
    WARNING = 'WARNING'
}

/**
 * 
 * @export
 * @interface ServiceStatusDto
 */
export interface ServiceStatusDto {
    /**
     * 
     * @type {Array<EnvironmentStatusDto>}
     * @memberof ServiceStatusDto
     */
    'environments': Array<EnvironmentStatusDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ServiceType {
    APPLICATION = 'APPLICATION',
    CONTAINER = 'CONTAINER',
    DATABASE = 'DATABASE',
    JOB = 'JOB'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum UnitDto {
    M_CPU = 'mCPU',
    MI_B = 'MiB'
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentLogsRequest: async (organization: string, cluster: string, project: string, environment: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'environment', environment)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('handleDeploymentLogsRequest', 'version', version)
            const localVarPath = `/deployment/logs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentStatusRequest: async (organization: string, cluster: string, project: string, environment: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'environment', environment)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('handleDeploymentStatusRequest', 'version', version)
            const localVarPath = `/deployment/status`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleDeploymentLogsRequest(organization: string, cluster: string, project: string, environment: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleDeploymentLogsRequest(organization, cluster, project, environment, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleDeploymentStatusRequest(organization: string, cluster: string, project: string, environment: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleDeploymentStatusRequest(organization, cluster, project, environment, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentLogsRequest(organization: string, cluster: string, project: string, environment: string, version: string, options?: any): AxiosPromise<string> {
            return localVarFp.handleDeploymentLogsRequest(organization, cluster, project, environment, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDeploymentStatusRequest(organization: string, cluster: string, project: string, environment: string, version: string, options?: any): AxiosPromise<string> {
            return localVarFp.handleDeploymentStatusRequest(organization, cluster, project, environment, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public handleDeploymentLogsRequest(organization: string, cluster: string, project: string, environment: string, version: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).handleDeploymentLogsRequest(organization, cluster, project, environment, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public handleDeploymentStatusRequest(organization: string, cluster: string, project: string, environment: string, version: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).handleDeploymentStatusRequest(organization, cluster, project, environment, version, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string} infraComponentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleInfraLogsRequest: async (organization: string, cluster: string, project: string, environment: string, service: string, infraComponentType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'service', service)
            // verify required parameter 'infraComponentType' is not null or undefined
            assertParamExists('handleInfraLogsRequest', 'infraComponentType', infraComponentType)
            const localVarPath = `/infra/logs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"infra_component_type"}}`, encodeURIComponent(String(infraComponentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceLogsRequest: async (organization: string, cluster: string, project: string, environment: string, service: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleServiceLogsRequest', 'service', service)
            const localVarPath = `/service/logs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string} infraComponentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleInfraLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, infraComponentType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInfraLogResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleInfraLogsRequest(organization, cluster, project, environment, service, infraComponentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleServiceLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceLogResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleServiceLogsRequest(organization, cluster, project, environment, service, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {string} infraComponentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleInfraLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, infraComponentType: string, options?: any): AxiosPromise<ServiceInfraLogResponseDto> {
            return localVarFp.handleInfraLogsRequest(organization, cluster, project, environment, service, infraComponentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, options?: any): AxiosPromise<ServiceLogResponseDto> {
            return localVarFp.handleServiceLogsRequest(organization, cluster, project, environment, service, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} service 
     * @param {string} infraComponentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public handleInfraLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, infraComponentType: string, options?: AxiosRequestConfig) {
        return LogsApiFp(this.configuration).handleInfraLogsRequest(organization, cluster, project, environment, service, infraComponentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} service 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public handleServiceLogsRequest(organization: string, cluster: string, project: string, environment: string, service: string, options?: AxiosRequestConfig) {
        return LogsApiFp(this.configuration).handleServiceLogsRequest(organization, cluster, project, environment, service, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceMetricsApi - axios parameter creator
 * @export
 */
export const ServiceMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {ServiceType} serviceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMetricsRequest: async (organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleMetricsRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleMetricsRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleMetricsRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleMetricsRequest', 'environment', environment)
            // verify required parameter 'service' is not null or undefined
            assertParamExists('handleMetricsRequest', 'service', service)
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('handleMetricsRequest', 'serviceType', serviceType)
            const localVarPath = `/service/metrics`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"service"}}`, encodeURIComponent(String(service)))
                .replace(`{${"service_type"}}`, encodeURIComponent(String(serviceType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceMetricsApi - functional programming interface
 * @export
 */
export const ServiceMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {ServiceType} serviceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleMetricsRequest(organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceMetricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleMetricsRequest(organization, cluster, project, environment, service, serviceType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceMetricsApi - factory interface
 * @export
 */
export const ServiceMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceMetricsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {string} service 
         * @param {ServiceType} serviceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMetricsRequest(organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options?: any): AxiosPromise<ServiceMetricsDto> {
            return localVarFp.handleMetricsRequest(organization, cluster, project, environment, service, serviceType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceMetricsApi - object-oriented interface
 * @export
 * @class ServiceMetricsApi
 * @extends {BaseAPI}
 */
export class ServiceMetricsApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {string} service 
     * @param {ServiceType} serviceType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceMetricsApi
     */
    public handleMetricsRequest(organization: string, cluster: string, project: string, environment: string, service: string, serviceType: ServiceType, options?: AxiosRequestConfig) {
        return ServiceMetricsApiFp(this.configuration).handleMetricsRequest(organization, cluster, project, environment, service, serviceType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceStatusApi - axios parameter creator
 * @export
 */
export const ServiceStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceStatusRequest: async (organization: string, cluster: string, project: string, environment: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'organization', organization)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'cluster', cluster)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'project', project)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('handleServiceStatusRequest', 'environment', environment)
            const localVarPath = `/service/status`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceStatusApi - functional programming interface
 * @export
 */
export const ServiceStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleServiceStatusRequest(organization: string, cluster: string, project: string, environment: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleServiceStatusRequest(organization, cluster, project, environment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceStatusApi - factory interface
 * @export
 */
export const ServiceStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceStatusApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organization 
         * @param {string} cluster 
         * @param {string} project 
         * @param {string} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleServiceStatusRequest(organization: string, cluster: string, project: string, environment: string, options?: any): AxiosPromise<ServiceStatusDto> {
            return localVarFp.handleServiceStatusRequest(organization, cluster, project, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceStatusApi - object-oriented interface
 * @export
 * @class ServiceStatusApi
 * @extends {BaseAPI}
 */
export class ServiceStatusApi extends BaseAPI {
    /**
     * 
     * @param {string} organization 
     * @param {string} cluster 
     * @param {string} project 
     * @param {string} environment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStatusApi
     */
    public handleServiceStatusRequest(organization: string, cluster: string, project: string, environment: string, options?: AxiosRequestConfig) {
        return ServiceStatusApiFp(this.configuration).handleServiceStatusRequest(organization, cluster, project, environment, options).then((request) => request(this.axios, this.basePath));
    }
}


